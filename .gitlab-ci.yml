stages:
  - test
  - exploit

variables:
  SERVER_CERT: server.crt
  SERVER_KEY: server.key
  CA_CERT: ca.crt
  CLIENT_CERT: client.crt
  CLIENT_KEY: client.key

test:
  stage: test
  image: golang:1.24
  script:
    - go mod download
    - go test -v ./...

exploit_poc:
  stage: exploit
  image: golang:1.24
  script:
    - echo "Starting Knox dev server..."
    - go run ./cmd/dev_server & 
    - SERVER_PID=$!
    - sleep 5

    - echo "Running malicious requests..."
    - |
      # Run exploit curl requests and save output
      curl -s -w "%{http_code}" http://localhost:8080/normal/path -o normal.txt || true
      curl -s -w "%{http_code}" http://localhost:8080/../../../etc/passwd -o exploit1.txt || true
      curl -s -w "%{http_code}" http://localhost:8080/api/v1/keys/../../../../../etc/passwd -o exploit2.txt || true
      curl -s -w "%{http_code}" "http://localhost:8080/%2e%2e/%2e%2e/%2e%2e/etc/passwd" -o exploit3.txt || true

    - echo "Killing Knox server..."
    - kill $SERVER_PID || true
    - wait $SERVER_PID 2>/dev/null || true

    - echo "Checking exploit results for suspicious content..."

    # Basic heuristic: if /etc/passwd appears in output, fail the job
    - if grep -q 'root:x:0:0:' exploit1.txt exploit2.txt exploit3.txt; then
        echo "Exploit SUCCESS: /etc/passwd content leaked!";
        exit 1;
      else
        echo "Exploit FAILURE: No leakage detected.";
      fi

  artifacts:
    paths:
      - normal.txt
      - exploit1.txt
      - exploit2.txt
      - exploit3.txt
      - knox.log
    expire_in: 1 week
